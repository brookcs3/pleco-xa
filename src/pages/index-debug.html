<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pleco-XA: Debug Version</title>
  <style>
    body { 
      font-family: monospace; 
      background: #111; 
      color: #0f8; 
      padding: 20px; 
    }
    .btn { 
      background: #333; 
      color: white; 
      border: 1px solid #666; 
      padding: 10px 20px; 
      margin: 5px; 
      cursor: pointer; 
    }
    .btn:hover { background: #555; }
    #log { 
      background: #000; 
      border: 1px solid #333; 
      padding: 10px; 
      margin: 10px 0; 
      height: 300px; 
      overflow-y: scroll; 
      font-size: 12px;
    }
  </style>
</head>
<body>
  <h1>Pleco-XA Debug Console</h1>
  
  <div>
    <button class="btn" data-sample="12-8-Jazzy-Drumset-03.aif">Jazz Drums</button>
    <button class="btn" data-sample="Drive Through Beat.aif">Drive Beat</button>
  </div>
  
  <div>
    <button class="btn" id="playBtn">‚ñ∂Ô∏è Play</button>
    <button class="btn" id="stopBtn">‚èπÔ∏è Stop</button>
  </div>
  
  <div>BPM: <span id="bpm">--</span></div>
  <div>Status: <span id="status">Ready</span></div>
  
  <div id="log"></div>

<script type="module">
  // Test what actually works
  const log = document.getElementById('log');
  
  function addLog(msg) {
    console.log(msg);
    log.innerHTML += msg + '<br>';
    log.scrollTop = log.scrollHeight;
  }
  
  addLog('üîç Testing imports...');
  
  try {
    // Test basic import that should work
    const { quick_tempo } = await import('/src/core/librosa-tempo.js');
    addLog('‚úÖ quick_tempo imported successfully');
    
    // Test recurrence imports
    const recurrence = await import('/src/core/librosa-recurrence.js');
    addLog('‚úÖ librosa-recurrence imported');
    addLog(`Available exports: ${Object.keys(recurrence).join(', ')}`);
    
  } catch (error) {
    addLog(`‚ùå Import error: ${error.message}`);
    addLog(`Stack: ${error.stack}`);
  }
  
  // Global state
  let audioCtx = null;
  let buffer = null;
  let srcNode = null;
  let isPlaying = false;
  
  // Basic audio loading test
  async function loadSample(url) {
    try {
      addLog(`üì• Loading: ${url}`);
      document.getElementById('status').textContent = 'Loading...';
      
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        addLog(`‚úÖ AudioContext created: ${audioCtx.state}`);
      }
      
      const response = await fetch(url);
      addLog(`üåê Fetch response: ${response.status} ${response.statusText}`);
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const arrayBuffer = await response.arrayBuffer();
      addLog(`üì¶ ArrayBuffer: ${arrayBuffer.byteLength} bytes`);
      
      buffer = await audioCtx.decodeAudioData(arrayBuffer);
      addLog(`üéµ Audio decoded: ${buffer.duration.toFixed(2)}s @ ${buffer.sampleRate}Hz`);
      
      document.getElementById('status').textContent = `Loaded: ${buffer.duration.toFixed(1)}s`;
      
      // Test BPM detection
      await testBPM();
      
    } catch (error) {
      addLog(`‚ùå Load error: ${error.message}`);
      document.getElementById('status').textContent = `Error: ${error.message}`;
    }
  }
  
  async function testBPM() {
    try {
      addLog('ü•Å Testing BPM detection...');
      
      const { quick_tempo } = await import('/src/core/librosa-tempo.js');
      const audioData = buffer.getChannelData(0);
      const sampleRate = buffer.sampleRate;
      
      addLog(`üìä Audio data: ${audioData.length} samples`);
      
      const bpm = quick_tempo(audioData, sampleRate);
      addLog(`‚úÖ BPM detected: ${bpm}`);
      
      document.getElementById('bpm').textContent = Math.round(bpm);
      
    } catch (error) {
      addLog(`‚ùå BPM error: ${error.message}`);
      addLog(`Stack: ${error.stack}`);
    }
  }
  
  async function play() {
    if (!buffer) {
      addLog('‚ùå No audio buffer loaded');
      return;
    }
    
    if (isPlaying) {
      stop();
      return;
    }
    
    try {
      if (audioCtx.state === 'suspended') {
        await audioCtx.resume();
      }
      
      srcNode = audioCtx.createBufferSource();
      srcNode.buffer = buffer;
      srcNode.connect(audioCtx.destination);
      srcNode.start();
      
      isPlaying = true;
      document.getElementById('playBtn').textContent = '‚è∏Ô∏è Pause';
      addLog('‚ñ∂Ô∏è Playback started');
      
    } catch (error) {
      addLog(`‚ùå Play error: ${error.message}`);
    }
  }
  
  function stop() {
    if (srcNode) {
      try {
        srcNode.stop();
      } catch {}
      srcNode = null;
    }
    isPlaying = false;
    document.getElementById('playBtn').textContent = '‚ñ∂Ô∏è Play';
    addLog('‚èπÔ∏è Playback stopped');
  }
  
  // Event listeners
  document.querySelectorAll('.btn[data-sample]').forEach(btn => {
    btn.addEventListener('click', () => {
      loadSample(`/audio/${btn.dataset.sample}`);
    });
  });
  
  document.getElementById('playBtn').addEventListener('click', play);
  document.getElementById('stopBtn').addEventListener('click', stop);
  
  addLog('üéµ Debug console ready');
</script>
</body>
</html>