<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pleco-XA: Audio Analysis</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
      background-attachment: fixed;
      min-height: 100vh;
      color: white;
      padding: 2rem;
    }

    .main-container {
      max-width: 1200px;
      margin: 0 auto;
    }

    .header {
      text-align: center;
      margin-bottom: 2rem;
    }

    .main-title {
      font-size: 3rem;
      font-weight: 800;
      margin-bottom: 1rem;
      background: linear-gradient(45deg, #ff6b6b, #ffd93d, #6bcf7f, #4ecdc4);
      background-size: 400% 400%;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: gradientShift 4s ease-in-out infinite;
    }

    @keyframes gradientShift {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }

    .audio-controls {
      text-align: center;
      margin-bottom: 2rem;
    }

    .sample-buttons {
      display: flex;
      gap: 1rem;
      justify-content: center;
      margin-bottom: 2rem;
      flex-wrap: wrap;
    }

    .sample-btn {
      padding: 1rem 2rem;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.3);
      border-radius: 25px;
      color: white;
      cursor: pointer;
      transition: all 0.3s ease;
      backdrop-filter: blur(10px);
    }

    .sample-btn:hover {
      background: rgba(255,255,255,0.2);
      transform: translateY(-3px);
    }

    .playback-controls {
      margin: 2rem 0;
    }

    .play-btn {
      padding: 1rem 2rem;
      background: linear-gradient(45deg, #ff6b6b, #ff8e8e);
      border: none;
      border-radius: 25px;
      color: white;
      font-weight: 600;
      cursor: pointer;
      margin: 0 0.5rem;
    }

    .analysis-display {
      display: grid;
      grid-template-columns: 1fr 2fr 1fr;
      gap: 2rem;
      margin-top: 2rem;
    }

    .bpm-display {
      text-align: center;
      background: rgba(255,255,255,0.05);
      border-radius: 20px;
      padding: 1.5rem;
      backdrop-filter: blur(15px);
      border: 1px solid rgba(255,255,255,0.1);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
    }

    .bpm-value {
      font-size: 3rem;
      font-weight: 900;
      color: #ffd700;
      text-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
      margin-bottom: 0.5rem;
    }

    .bpm-label {
      font-size: 1.2rem;
      opacity: 0.8;
    }

    .timeline-container {
      position: relative;
      width: 150px;
      height: 150px;
    }

    .timeline-circle {
      width: 100%;
      height: 100%;
      border: 3px solid rgba(255,255,255,0.2);
      border-radius: 50%;
      position: relative;
      background: radial-gradient(circle, rgba(255,255,255,0.05), transparent);
    }

    .timeline-hand {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 2px;
      height: 60px;
      background: linear-gradient(180deg, #ffd700, #ff6b6b);
      transform-origin: bottom;
      transform: translate(-50%, -100%) rotate(0deg);
      transition: transform 0.1s ease;
      border-radius: 2px;
    }

    .timeline-center {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 12px;
      height: 12px;
      background: #ffd700;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
    }

    .timeline-marker {
      position: absolute;
      top: 5px;
      left: 50%;
      width: 3px;
      height: 15px;
      background: #4ecdc4;
      transform: translateX(-50%);
      border-radius: 2px;
    }

    .waveform-container {
      background: rgba(255,255,255,0.05);
      border-radius: 20px;
      padding: 2rem;
      backdrop-filter: blur(15px);
      border: 1px solid rgba(255,255,255,0.1);
    }

    .waveform-title {
      font-size: 1.5rem;
      margin-bottom: 1rem;
      color: #ffd700;
      text-align: center;
    }

    .waveform-canvas {
      width: 100%;
      height: 200px;
      background: rgba(0,0,0,0.3);
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.1);
    }

    .loop-controls {
      display: flex;
      gap: 1rem;
      margin-top: 1rem;
      flex-wrap: wrap;
      justify-content: center;
    }

    .loop-btn {
      padding: 0.8rem 1.5rem;
      background: linear-gradient(45deg, #ff6b6b, #ff8e8e);
      border: none;
      border-radius: 25px;
      color: white;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 0.9rem;
    }

    .loop-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 15px rgba(0,0,0,0.3);
    }

    .analysis-cards {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .analysis-card {
      background: rgba(255,255,255,0.05);
      border-radius: 15px;
      padding: 1.5rem;
      backdrop-filter: blur(15px);
      border: 1px solid rgba(255,255,255,0.1);
    }

    .card-title {
      font-size: 1.1rem;
      font-weight: 600;
      margin-bottom: 0.5rem;
      color: #ffd700;
    }

    .card-value {
      font-size: 1.5rem;
      font-weight: bold;
      color: white;
      margin-bottom: 0.5rem;
    }

    .card-description {
      font-size: 0.8rem;
      opacity: 0.7;
      line-height: 1.4;
    }

    @media (max-width: 768px) {
      .analysis-display {
        grid-template-columns: 1fr;
        gap: 1rem;
      }
      
      .main-title {
        font-size: 2rem;
      }
      
      .bmp-value {
        font-size: 2.5rem;
      }
    }
  </style>
</head>
<body>
  <div class="main-container">
    <div class="header">
      <h1 class="main-title">Pleco-XA</h1>
      <p>Audio Analysis Engine</p>
    </div>

    <div class="audio-controls">
      <div class="sample-buttons">
        <button class="sample-btn" data-sample="12-8-Jazzy-Drumset-03.aif">Jazz Drums</button>
        <button class="sample-btn" data-sample="Bassline For Doppler Song - 11.aif">Bassline</button>
        <button class="sample-btn" data-sample="Drive Through Beat.aif">Drive Beat</button>
        <button class="sample-btn" data-sample="ui.m4a">UI Loop Test</button>
      </div>

      <div class="playback-controls">
        <button class="play-btn" id="playBtn">‚ñ∂Ô∏è Play</button>
        <button class="play-btn" id="stopBtn">‚èπÔ∏è Stop</button>
      </div>
    </div>

    <div class="analysis-display">
      <div class="bpm-display">
        <div class="bpm-value" id="bpmValue">--</div>
        <div class="bpm-label">BPM</div>
        
        <div class="timeline-container">
          <div class="timeline-circle">
            <div class="timeline-hand" id="timelineHand"></div>
            <div class="timeline-center"></div>
            <div class="timeline-marker"></div>
          </div>
        </div>
      </div>

      <div class="waveform-container">
        <h3 class="waveform-title">Waveform & Loop Detection</h3>
        <canvas class="waveform-canvas" id="waveformCanvas" width="800" height="200"></canvas>
        <div class="loop-controls">
          <button class="loop-btn" id="detectLoopBtn">üîç Detect Loop</button>
          <button class="loop-btn" id="halfLoopBtn">Half Loop</button>
          <button class="loop-btn" id="doubleLoopBtn">Double Loop</button>
          <button class="loop-btn" id="moveForwardBtn">Move Forward</button>
          <button class="loop-btn" id="reverseLoopBtn">üîÑ Reverse Loop</button>
          <button class="loop-btn" id="resetPlayheadBtn">üìè Reset Playhead</button>
          <button class="loop-btn" id="resetLoopBtn">Reset Loop</button>
        </div>
      </div>

      <div class="analysis-cards">
        <div class="analysis-card">
          <h4 class="card-title">Track Info</h4>
          <div class="card-value" id="trackName">No track loaded</div>
          <p class="card-description" id="trackStatus">Load a sample to begin</p>
        </div>

        <div class="analysis-card">
          <h4 class="card-title">Loop Status</h4>
          <div class="card-value" id="loopInfo">Full Track</div>
          <p class="card-description">Current loop boundaries</p>
        </div>

        <div class="analysis-card">
          <h4 class="card-title">Audio Format</h4>
          <div class="card-value" id="audioFormat">--</div>
          <p class="card-description">Decoded audio information</p>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    /* --------  Librosa-recurrence for loops  -------- */
    import {
      computeChroma,        // 12-bin chroma features
      stackMemory,          // time-delay embedding
      recurrenceMatrix,     // self-similarity map
      recurrenceToLag,      // converts R‚Üílag curve
    } from '/src/core/librosa-recurrence.js';

    /* --------  Onset detection for BPM  -------- */
    import { computeSpectralFlux, computeSTFT } from '/src/core/librosa-onset.js';
    
    // Global variables
    let audioContext;
    let currentAudioBuffer = null;
    let currentSource = null;
    let isPlaying = false;
    let currentBPM = 120;
    let currentLoop = { start: 0, end: 1 };
    let playheadStartTime = 0;
    let playheadAnimationId = null;

    // Global error handler
    window.addEventListener('error', (e) => {
      console.error('Global error:', e.error);
      showError(`Global error: ${e.error.message}`);
    });

    window.addEventListener('unhandledrejection', (e) => {
      console.error('Unhandled promise rejection:', e.reason);
      showError(`Promise error: ${e.reason}`);
    });

    function showError(message) {
      // Show error in the UI
      const errorDiv = document.getElementById('errorDisplay') || createErrorDisplay();
      errorDiv.textContent = message;
      errorDiv.style.display = 'block';
      
      // Auto-hide after 5 seconds
      setTimeout(() => {
        errorDiv.style.display = 'none';
      }, 5000);
    }

    function createErrorDisplay() {
      const errorDiv = document.createElement('div');
      errorDiv.id = 'errorDisplay';
      errorDiv.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #ff4444;
        color: white;
        padding: 10px;
        border-radius: 5px;
        z-index: 1000;
        max-width: 400px;
        display: none;
      `;
      document.body.appendChild(errorDiv);
      return errorDiv;
    }

    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
      console.log('üéµ Pleco-XA loading...');
      try {
        setupEventListeners();
        console.log('‚úÖ Event listeners set up');
      } catch (error) {
        console.error('‚ùå Failed to set up event listeners:', error);
        showError(`Setup error: ${error.message}`);
      }
    });

    function setupEventListeners() {
      // Sample buttons
      const sampleBtns = document.querySelectorAll('.sample-btn');
      console.log(`üéõÔ∏è Found ${sampleBtns.length} sample buttons`);
      
      sampleBtns.forEach((btn, index) => {
        console.log(`  Button ${index}: ${btn.textContent} -> ${btn.dataset.sample}`);
        btn.addEventListener('click', () => {
          console.log(`üéµ Loading: ${btn.textContent}`);
          loadSampleFile(`/audio/${btn.dataset.sample}`, btn.textContent);
        });
      });

      // Playback controls
      document.getElementById('playBtn').addEventListener('click', playAudio);
      document.getElementById('stopBtn').addEventListener('click', stopAudio);

      // Loop controls
      document.getElementById('detectLoopBtn').addEventListener('click', detectLoop);
      document.getElementById('halfLoopBtn').addEventListener('click', halfLoop);
      document.getElementById('doubleLoopBtn').addEventListener('click', doubleLoop);
      document.getElementById('moveForwardBtn').addEventListener('click', moveForward);
      document.getElementById('reverseLoopBtn').addEventListener('click', reverseLoopSection);
      document.getElementById('resetPlayheadBtn').addEventListener('click', resetPlayhead);
      document.getElementById('resetLoopBtn').addEventListener('click', resetLoop);
    }

    async function loadSampleFile(url, name) {
      try {
        console.log(`üì• Starting load: ${url}`);
        updateTrackInfo(name, 'Loading...');
        
        if (!audioContext) {
          console.log('üéß Creating AudioContext...');
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
          console.log(`‚úÖ AudioContext created: ${audioContext.state}`);
        }
        
        console.log(`üåê Fetching: ${url}`);
        const response = await fetch(url);
        if (!response.ok) throw new Error(`HTTP ${response.status} - ${response.statusText}`);
        console.log(`‚úÖ Fetch successful: ${response.headers.get('content-type')}`);
        
        console.log('üîÑ Converting to ArrayBuffer...');
        const arrayBuffer = await response.arrayBuffer();
        console.log(`‚úÖ ArrayBuffer size: ${arrayBuffer.byteLength} bytes`);
        
        console.log('üéµ Decoding audio data...');
        currentAudioBuffer = await audioContext.decodeAudioData(arrayBuffer);
        console.log(`‚úÖ Audio decoded: ${currentAudioBuffer.duration.toFixed(2)}s, ${currentAudioBuffer.sampleRate}Hz`);
        
        updateTrackInfo(name, `${currentAudioBuffer.duration.toFixed(1)}s`);
        document.getElementById('audioFormat').textContent = `${currentAudioBuffer.sampleRate}Hz`;
        
        // BPM detection
        console.log('ü•Å Starting BPM detection...');
        detectBPM();
        
        // Draw waveform
        console.log('üìä Drawing waveform...');
        drawWaveform();
        
        console.log('‚úÖ Audio loaded successfully');
      } catch (error) {
        console.error('‚ùå Error loading audio:', error);
        showError(`Load error: ${error.message}`);
        updateTrackInfo('Error', error.message);
      }
    }

    // Simple working tempo detection using spectral flux
    function simpleTempo(y, sr = 22050) {
      const stft = computeSTFT(y, 2048, 512);
      const onsetStrength = computeSpectralFlux(stft);
      
      // Simple autocorrelation for tempo
      const hopLength = 512;
      const minTempo = 60;
      const maxTempo = 200;
      
      // Convert tempo range to lag range (in frames)
      const minLag = Math.floor(60 * sr / (maxTempo * hopLength));
      const maxLag = Math.floor(60 * sr / (minTempo * hopLength));
      
      let bestBPM = 120;
      let maxCorr = 0;
      
      // Autocorrelation to find periodicity
      for (let lag = minLag; lag < Math.min(maxLag, onsetStrength.length / 2); lag++) {
        let corr = 0;
        let count = 0;
        
        for (let i = 0; i < onsetStrength.length - lag; i++) {
          corr += onsetStrength[i] * onsetStrength[i + lag];
          count++;
        }
        
        if (count > 0) {
          corr /= count;
          if (corr > maxCorr) {
            maxCorr = corr;
            const period = lag * hopLength / sr;
            const bpm = 60 / period;
            if (bpm >= minTempo && bpm <= maxTempo) {
              bestBPM = bpm;
            }
          }
        }
      }
      
      return {
        bpm: bestBPM,
        confidence: Math.min(maxCorr * 10, 1) // rough confidence estimate
      };
    }

    function detectBPM() {
      try {
        console.log('üîç Getting audio data...');
        const y  = currentAudioBuffer.getChannelData(0);
        const sr = currentAudioBuffer.sampleRate;
        console.log(`üìä Audio data: ${y.length} samples at ${sr}Hz`);

        console.log('ü•Å Calling simpleTempo() function...');
        const result = simpleTempo(y, sr);   // working estimator
        console.log('‚úÖ simpleTempo() returned:', result);
        
        const { bpm, confidence } = result;
        console.log(`üéµ BPM ${bpm.toFixed(1)} (conf ${Math.round(confidence*100)}%)`);
        
        currentBPM = bpm;
        document.getElementById('bpmValue').textContent = bpm.toFixed(1);
        console.log(`‚úÖ BPM detection complete: ${bpm}`);
      } catch (error) {
        console.error('‚ùå Error in BPM detection:', error);
        showError(`BPM detection failed: ${error.message}`);
        currentBPM = 120;
        document.getElementById('bpmValue').textContent = currentBPM;
      }
    }

    function detectLoop() {
      try {
        const chroma = computeChroma(currentAudioBuffer);                     // 12√óN
        const feats  = stackMemory(chroma, 8, 3);              // (12√ó8)√óM
        const R      = recurrenceMatrix(feats, null, 1, 'euclidean', true);
        const lagArr = recurrenceToLag(R);                     // strength vs lag

        // grab lag (in frames) with max strength, skip the trivial lag=0
        const bestLagFrames = lagArr.indexOf(
          Math.max(...lagArr.slice(1))
        );

        // translate frames ‚Üí seconds
        const hop  = 512;                          // fixed in computeChroma()
        const loopSecs = bestLagFrames * hop / currentAudioBuffer.sampleRate;

        const loop = { start: 0, end: loopSecs };
        currentLoop = { start: 0, end: loopSecs / currentAudioBuffer.duration };
        
        console.log(`Detected loop: ${loopSecs.toFixed(2)}s`);
        document.getElementById('loopInfo').textContent = `${loopSecs.toFixed(2)}s Loop`;
        
        // Redraw waveform with new loop
        drawWaveform();
        
        return loop;
      } catch (error) {
        console.error('Error in loop detection:', error);
        return { start: 0, end: currentAudioBuffer.duration };
      }
    }

    function drawWaveform() {
      const canvas = document.getElementById('waveformCanvas');
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      
      // Clear canvas
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, width, height);
      
      if (!currentAudioBuffer) return;
      
      const audioData = currentAudioBuffer.getChannelData(0);
      
      // Draw waveform
      ctx.strokeStyle = '#00ff88';
      ctx.lineWidth = 1;
      ctx.beginPath();
      
      const step = Math.ceil(audioData.length / width);
      for (let i = 0; i < width; i++) {
        const slice = audioData.slice(i * step, (i + 1) * step);
        const max = Math.max(...slice);
        const min = Math.min(...slice);
        
        const yMax = (1 - max) * height / 2;
        const yMin = (1 - min) * height / 2;
        
        ctx.moveTo(i, yMax);
        ctx.lineTo(i, yMin);
      }
      ctx.stroke();
      
      // Draw loop boundaries
      const startX = currentLoop.start * width;
      const endX = currentLoop.end * width;
      
      // Loop region highlight
      ctx.fillStyle = 'rgba(255, 215, 0, 0.1)';
      ctx.fillRect(startX, 0, endX - startX, height);
      
      // Loop markers
      ctx.strokeStyle = '#ffd700';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(startX, 0);
      ctx.lineTo(startX, height);
      ctx.moveTo(endX, 0);
      ctx.lineTo(endX, height);
      ctx.stroke();
      
      // Draw playhead if playing
      if (isPlaying) {
        drawPlayhead(ctx, width, height);
      }
      
      updateLoopInfo();
    }

    async function playAudio() {
      if (!currentAudioBuffer) {
        alert('Please load an audio file first!');
        return;
      }
      
      if (isPlaying) {
        stopAudio();
        return;
      }
      
      try {
        if (audioContext.state === 'suspended') {
          await audioContext.resume();
        }
        
        currentSource = audioContext.createBufferSource();
        currentSource.buffer = currentAudioBuffer;
        currentSource.connect(audioContext.destination);
        currentSource.loop = true;
        
        const startTime = currentLoop.start * currentAudioBuffer.duration;
        const endTime = currentLoop.end * currentAudioBuffer.duration;
        
        currentSource.loopStart = startTime;
        currentSource.loopEnd = endTime;
        currentSource.start(0, startTime);
        
        isPlaying = true;
        playheadStartTime = audioContext.currentTime;
        startPlayheadAnimation();
        startTimelineAnimation();
        document.getElementById('playBtn').textContent = '‚è∏Ô∏è Pause';
        
      } catch (error) {
        console.error('Playback error:', error);
      }
    }

    function stopAudio() {
      if (currentSource) {
        try {
          currentSource.stop();
        } catch (error) {
          // Source may already be stopped
        }
        currentSource = null;
      }
      isPlaying = false;
      stopPlayheadAnimation();
      document.getElementById('playBtn').textContent = '‚ñ∂Ô∏è Play';
    }


    function halfLoop() {
      console.log('üéØ Half Loop clicked');
      const duration = currentLoop.end - currentLoop.start;
      const newDuration = duration / 2;
      
      // Check minimum duration (50ms)
      if (!currentAudioBuffer) return;
      const actualNewDurationMs = newDuration * currentAudioBuffer.duration * 1000;
      
      if (actualNewDurationMs < 50) {
        console.log(`Cannot halve - new loop would be ${actualNewDurationMs.toFixed(1)}ms (minimum: 50ms)`);
        return;
      }
      
      console.log(`Halving loop: ${duration.toFixed(4)} -> ${newDuration.toFixed(4)}`);
      currentLoop.end = currentLoop.start + newDuration;
      
      drawWaveform();
      
      if (isPlaying) {
        console.log('Restarting playback with new loop bounds');
        stopAudio();
        setTimeout(() => playAudio(), 50);
      }
    }

    function doubleLoop() {
      console.log('üéØ Double Loop clicked');
      const currentDuration = currentLoop.end - currentLoop.start;
      const newDuration = currentDuration * 2;
      const newEnd = currentLoop.start + newDuration;
      
      if (newEnd > 1) {
        console.log(`Cannot double - new loop would extend past track end (${newEnd.toFixed(4)} > 1.0)`);
        return;
      }
      
      console.log(`Doubling loop: ${currentDuration.toFixed(4)} -> ${newDuration.toFixed(4)}`);
      currentLoop.end = newEnd;
      
      drawWaveform();
      
      if (isPlaying) {
        console.log('Restarting playback with new loop bounds');
        stopAudio();
        setTimeout(() => playAudio(), 50);
      }
    }

    function moveForward() {
      console.log('üéØ Move Forward clicked');
      const duration = currentLoop.end - currentLoop.start;
      
      // Check if we can move forward
      if (currentLoop.start + duration >= 1) {
        console.log('Cannot move forward - not enough space for current loop size');
        return;
      }
      
      // Move the loop forward by its current duration
      const newStart = currentLoop.start + duration;
      const newEnd = currentLoop.end + duration;
      
      // Make sure we don't go past the end
      if (newEnd > 1) {
        currentLoop.start = 1 - duration;
        currentLoop.end = 1;
        console.log('Moved to end segment');
      } else {
        currentLoop.start = newStart;
        currentLoop.end = newEnd;
        console.log(`Moved loop: ${newStart.toFixed(4)} - ${newEnd.toFixed(4)}`);
      }
      
      drawWaveform();
      
      if (isPlaying) {
        console.log('Restarting playback with new loop bounds');
        stopAudio();
        setTimeout(() => playAudio(), 50);
      }
    }

    function resetLoop() {
      currentLoop = { start: 0, end: 1 };
      drawWaveform();
      
      if (isPlaying) {
        stopAudio();
        setTimeout(() => playAudio(), 50);
      }
    }

    function updateTrackInfo(name, status) {
      document.getElementById('trackName').textContent = name;
      document.getElementById('trackStatus').textContent = status;
    }

    function updateLoopInfo() {
      if (!currentAudioBuffer) return;
      
      const startTime = currentLoop.start * currentAudioBuffer.duration;
      const endTime = currentLoop.end * currentAudioBuffer.duration;
      const duration = endTime - startTime;
      
      if (currentLoop.start === 0 && currentLoop.end === 1) {
        document.getElementById('loopInfo').textContent = 'Full Track';
      } else {
        document.getElementById('loopInfo').textContent = `${duration.toFixed(1)}s Loop`;
      }
    }

    function drawPlayhead(ctx, width, height) {
      if (!currentAudioBuffer || !isPlaying) return;
      
      // Calculate current playback position
      const currentTime = audioContext.currentTime;
      const elapsed = currentTime - playheadStartTime;
      
      // Get loop bounds in seconds
      const loopStartSec = currentLoop.start * currentAudioBuffer.duration;
      const loopEndSec = currentLoop.end * currentAudioBuffer.duration;
      const loopDuration = loopEndSec - loopStartSec;
      
      // Calculate position within the loop (with wrapping)
      const positionInLoop = elapsed % loopDuration;
      const currentPosition = loopStartSec + positionInLoop;
      
      // Convert to normalized position (0-1)
      const normalizedPosition = currentPosition / currentAudioBuffer.duration;
      
      // Convert to pixel position
      const playheadX = normalizedPosition * width;
      
      // Draw playhead line
      ctx.strokeStyle = '#ff4444';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(playheadX, 0);
      ctx.lineTo(playheadX, height);
      ctx.stroke();
      
      // Draw playhead marker at top
      ctx.fillStyle = '#ff4444';
      ctx.beginPath();
      ctx.moveTo(playheadX, 0);
      ctx.lineTo(playheadX - 5, 10);
      ctx.lineTo(playheadX + 5, 10);
      ctx.closePath();
      ctx.fill();
    }

    function startPlayheadAnimation() {
      function animate() {
        if (isPlaying && currentAudioBuffer) {
          drawWaveform();
          playheadAnimationId = requestAnimationFrame(animate);
        }
      }
      playheadAnimationId = requestAnimationFrame(animate);
    }

    function stopPlayheadAnimation() {
      if (playheadAnimationId) {
        cancelAnimationFrame(playheadAnimationId);
        playheadAnimationId = null;
      }
      // Redraw waveform without playhead
      if (currentAudioBuffer) {
        drawWaveform();
      }
    }

    function reverseLoopSection() {
      if (!currentAudioBuffer) {
        alert('No audio loaded!');
        return;
      }
      
      // Reverse the current loop section
      const reversedBuffer = reverseAudioLoop(currentAudioBuffer, currentLoop);
      currentAudioBuffer = reversedBuffer;
      
      // Update visual
      drawWaveform();
      
      // If playing, restart with reversed audio
      if (isPlaying) {
        stopAudio();
        setTimeout(() => playAudio(), 50);
      }
    }

    function reverseAudioLoop(audioBuffer, loopBounds) {
      // Create new buffer with same properties
      const newBuffer = audioContext.createBuffer(
        audioBuffer.numberOfChannels,
        audioBuffer.length,
        audioBuffer.sampleRate
      );
      
      // Process each channel
      for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {
        const originalData = audioBuffer.getChannelData(channel);
        const newData = newBuffer.getChannelData(channel);
        
        // Copy original data
        for (let i = 0; i < originalData.length; i++) {
          newData[i] = originalData[i];
        }
        
        // Calculate loop boundaries in samples
        const loopStartSample = Math.floor(loopBounds.start * audioBuffer.duration * audioBuffer.sampleRate);
        const loopEndSample = Math.floor(loopBounds.end * audioBuffer.duration * audioBuffer.sampleRate);
        const loopLength = loopEndSample - loopStartSample;
        
        // Reverse just the loop section
        for (let i = 0; i < loopLength; i++) {
          const originalIndex = loopStartSample + i;
          const reversedIndex = loopStartSample + (loopLength - 1 - i);
          newData[originalIndex] = originalData[reversedIndex];
        }
      }
      
      return newBuffer;
    }

    function resetPlayhead() {
      // Reset playhead to full length without restoring original audio
      currentLoop = { start: 0, end: 1 };
      
      if (currentAudioBuffer) {
        // Update visual (keep any reversed sections visible)
        drawWaveform();
        
        // If playing, do quick stop/play to reset playhead to full track
        if (isPlaying) {
          stopAudio();
          setTimeout(() => playAudio(), 50);
        }
      }
    }

    function startTimelineAnimation() {
      if (!currentAudioBuffer) return;
      
      // Calculate actual loop duration in seconds
      const loopDuration = currentLoop.end - currentLoop.start;
      const actualDuration = loopDuration * currentAudioBuffer.duration;
      
      // Reset timeline position
      const timelineHand = document.getElementById('timelineHand');
      timelineHand.style.transform = 'translate(-50%, -100%) rotate(0deg)';
      
      // Animate timeline hand rotation to match loop duration
      const startTime = Date.now();
      
      function animateTimeline() {
        if (!isPlaying) return;
        
        const elapsed = (Date.now() - startTime) / 1000;
        const progress = (elapsed % actualDuration) / actualDuration;
        const rotation = progress * 360;
        
        timelineHand.style.transform = `translate(-50%, -100%) rotate(${rotation}deg)`;
        
        requestAnimationFrame(animateTimeline);
      }
      
      requestAnimationFrame(animateTimeline);
    }
  </script>
</body>
</html>